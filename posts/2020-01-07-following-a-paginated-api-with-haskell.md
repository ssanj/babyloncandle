---
title: Following a Paginated API with Haskell
author: sanjiv sahayam
description: ???
tags: haskell
comments: true
---

I've been using the [Twitter API]() for [Milo]() - a little command line application that limits my interaction with
Twitter to a select few accounts and searches. As with most APIs that have a large number of results, the Twitter API
is paginated and you need to keep supplying it with some manner of cursor when going from one page of results to the 
next. 

For the purposes of Milo, I wanted to access the latest direct messages for my user. Unfortunately the call to
get your direct messages may return multiple pages of "empty" results and a cursor to the next page of results. I wanted
to navigate these empty results and grab the first page with any results that were not empty.

An example of an empty result:

```{.json .scrollx}
{
  "next_cursor": "some_hash",
  "events": []
}
```


I initially came up with this solution:


```{.haskell .scrollx}
-- Wrapper around the hash return by the Twitter API
newtype Cursor = Cursor { unCursor :: T.Text } deriving Show

-- Function that returns the direct messages or an error
getDirectMessages :: IO (Either String DirectMessages)
getDirectMessages = getMoreDirectMessages Nothing


-- Function that loops through the result pages using a cursor
getMoreDirectMessages :: Maybe Cursor -> IO (Either String DirectMessages)
getMoreDirectMessages nextCursor = do
  dmsE <- callTwitterApi nextCursor
  case dmsE of
    Right dms@(DirectMessages messageList (Just nextCursor')) -> 
      if (null messageList) then -- if the messages are empty try to get more
        do
          (fmap (combineDms dms)) <$> (getMoreDirectMessages (Just . Cursor $ nextCursor'))
      else pure . Right $ dms

    Right dms@(DirectMessages _ Nothing) -> pure (Right dms) -- No more cursors so just stop
    Left dmError -> pure . Left $ dmError


-- Function that collates direct messages
combineDms :: DirectMessages -> DirectMessages -> DirectMessages

-- Function that calls the Twitter API with the cursor (if any)
callTwitterApi :: Maybe Cursor -> IO (Either String DirectMessages)
```

Now while this works it has a few problems:

1. It does not look very reusable, which it should be because pagination is a common problem
1. There are dangling error cases where we just lift the error into some outer context

At this point I recalled seeing a function called `unfold` somewhere and decided to track it down. I found [unfoldr](http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:unfoldr)
which sort of fitted what I needed.


## unfoldr

```{.haskell .scrollx}
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
```

From the docs:

> The unfoldr function is a `dual' to foldr: while foldr reduces a list to a summary value, unfoldr builds a list from a seed value. The function takes the element and returns Nothing if it is done producing the list or returns Just (a,b), in which case, a is a prepended to the list and b is used as the next element in a recursive call.


This sounded promising. I needed to keep "producing" direct message results and stop as soon as I got some results that 
were not empty. Unfortunately I needed to work within an effect (`IO`) which this function did not support.

In any event let's try and understand how this function works. This is the implementation of the the `unfoldr` function:

```{.haskell .scrollx}
unfoldr      :: (a -> Maybe (b, a)) -> a -> [b]
unfoldr f a  =
  case f a of
   Just (b,new_a) -> b : unfoldr f new_a
   Nothing        -> []
```

Given some generator function `f` that takes a value of type `a`, call `f` with `a` which returns either a `Just` value
with a new result `b` and the next value of `a`: `new_a`, in which case the result is prepended to a list of results which
will be generated by recursively calling the `unfoldr` function with `f` and `new_a` or if the result of calling `f` with `a` is `Nothing`
then return an empty List.

Here's a simple example that produces numbers from 1 to 10 inclusive and then stops:


```{.haskell .scrollx}
import Data.List (unfoldr)

unfoldr (\a -> if a < 11 then Just (a, a + 1) else Nothing) 1
> [1,2,3,4,5,6,7,8,9,10]
```

Pretty neat but not what I exactly needed.

After some more digging around I stumbled across a library called [monad-loops](http://hackage.haskell.org/package/monad-loops)
which had what I was after.


## unfoldrM


```{.haskell .scrollx}
unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
```

We can see from its function definition that it's exactly the same as `unfoldr` except the intermediate and final results
are within some `Monad m`:

```{.haskell .scrollx}
unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
unfoldr  ::            (a ->    Maybe (b, a))  -> a ->   [b]
```

This is the implementation for the `unfoldrM` function (which is an alias to `unfoldrM'`):

```{.haskell .scrollx}
unfoldrM' :: (Monad m, MonadPlus f) => (a -> m (Maybe (b,a))) -> a -> m (f b)
unfoldrM' f = go
    where go a = do
            x <- f a
            case x of
                Nothing         -> return mzero
                Just (b, new_a)    -> do
                        rest <- go new_a
                        return (return b `mplus` rest)
```

The implementation is very similar to `unfoldr` with differences due to the selected effect type `m` and result type `f`.

Given some generator function `f` that takes a value of type `a`, we call `f` with `a` which returns a `Maybe` with a
pair of values; the result `b` and the next value of type `a`:, `new_a`, within a context `m`. It sequences the contextual result
in the `do` block and pattern matchs on the result. If it's a `Nothing` it returns the default value for the `MonadPlus` type `f`. 
If the result is a `Just`, it creates another `do` block and recurses with the `new_a` value to sequence the final result `rest`. It then
combines the `rest` with the previous result `b` according to the `mplus` implementation for the `MonadPlus` type `f` and 
returns the results in the context `m`.


## The solution

Now while this seemed to be what I needed it took a little while for me to understand how to use it in my use case. One
thing that stumped me was why the initial value `a` was not a `Maybe`. Surely the first time I called the Twitter API,
I would not have a cursor, so how could I represent it as an `a`?  Event if I did make `a` a `Maybe a`, how would I 
distinguish between the initial call where I had no cursor and the final call where I would also have no cursor?!

My friend [Adam](ajfitzpatrick) states the obvious so I could understand it:

> Obviously you need more than two states

Oh dear! Was I supposed to create some ADT with three states? I thought this was supposed to be some plug-and-play solution
and it was turning out not to be.

I started off my creating the ADT for the states:

```{.haskell .scrollx}
-- | An ADT to capture the three states of a cursor:
-- NewCursor - Initial cursor state
-- GoCursor - A state of having a cursor, typically used for iteration
-- StopCursor - The final cursor state
data CursorState a = NewCursor | GoCursor (Cursor a) | StopCursor
```

Now if I plug in my `CursorState` type into `unfoldrM` as `a` I get the following:

```{.haskell .scrollx}
unfoldrM (a -> m (Maybe (b, a))) -> a -> m [b]
-- a is CursorState c
-- c is the type of cursor data
unfoldrM :: (CursorState c -> m (Maybe (b, CursorState c))) -> CursorState c -> m [b]
-- m is IO
unfoldrM :: (CursorState -> IO (Maybe (b, CursorState c ))) -> CursorState c -> IO [b]
-- b is DirectMessages
unfoldrM :: (CursorState c -> IO (Maybe (DirectMessages, CursorState c))) -> CursorState c -> IO [DirectMessages]
```

Now this seems to make sense, given a `CursorState` and function that takes that `CursorState` and returns some result
in an IO context with a `Just` with a pair of `DirectMessages` and the new `CursorState` if there are more results or an
IO with `Nothing` if there are no more results.

Given that I already had a function of type:

```{.haskell .scrollx}
callTwitterApi :: Maybe Cursor -> IO (Either String DirectMessages)
```

How could I convert it to work with the above function definition?

I could define a function `unfoldWith` as:


```{.haskell .scrollx}
unfoldWith :: forall m b c. CursorState c ->  m (Maybe (b, CursorState c))
unfoldWith NewCursor = undefined
unfoldWith (GoCursor (Cursor nextCursor)) = undefined
unfoldWith StopCursor = undefined
```

The simplest one to define is the `StopCursor` variant:

```{.haskell .scrollx}
unfoldWith :: forall m b c. Applicative m => CursorState c ->  m (Maybe (b, CursorState c))
unfoldWith NewCursor = undefined
unfoldWith (GoCursor (Cursor nextCursor)) = undefined
unfoldWith StopCursor = pure Nothing
```

and that compiles!

Next we can try and implement the `NewCursor` variant:

```{.haskell .scrollx}
unfoldWith :: forall m b c. Applicative m => CursorState ->  m (Maybe (b, CursorState))
unfoldWith NewCursor = undefined -- I need to be able to use callTwitterApi here
unfoldWith (GoCursor (Cursor nextCursor)) = undefined
unfoldWith StopCursor = pure Nothing
```

generalising the `callTwitterApi` function:


```{.haskell .scrollx}
callTwitterApi :: Maybe Cursor -> IO (Either String DirectMessages)
-- IO (Either String) is m
-- DirectMessages is a
someApi :: Maybe Cursor -> m a

-- passing in someApi to unfoldWith

unfoldWith :: forall m a b c. Applicative m => (Maybe (Cursor c) -> m a) -> CursorState ->  m (Maybe (b, CursorState))
unfoldWith f NewCursor = f Nothing -- call it with Nothing because we don't have a Cursor
unfoldWith f (GoCursor (Cursor nextCursor)) = undefined
unfoldWith _ StopCursor = pure Nothing
```

So far so good. But now we need to extract the result and the next cursor from response of the api call. When we call 
`someApi` we get a `m a` in return:

```{.haskell .scrollx}
someApi :: Maybe Cursor -> m a
```

We need a function that transforms that `a` in a pair of `(b, CursorState)`:

```{.haskell .scrollx}
extractPayload :: a -> (b, CusorState)
```

passing that into our `unfoldWith` function:

```{.haskell .scrollx}
unfoldWith :: forall m a b c. Applicative m => (a -> (b, CursorState c)) -> (Maybe (Cursor c) -> m a) -> CursorState ->  m (Maybe (b, CursorState))
unfoldWith extractPayload iterateWith NewCursor = 
  let resultM :: m a = iterateWith Nothing
  in  Just . extractPayload <$> resultM
unfoldWith extract f (GoCursor (Cursor nextCursor)) = undefined
unfoldWith _ _ StopCursor = pure Nothing
```

Seems to compile. Now we do the same of the `GoCursor` case:

```{.haskell .scrollx}
unfoldWith :: forall m a b c. Applicative m => (a -> (b, CursorState c)) -> (Maybe (Cursor c) -> m a) -> CursorState ->  m (Maybe (b, CursorState))
unfoldWith extractPayload iterateWith NewCursor = 
  let resultM :: m a = iterateWith Nothing
  in  Just . extractPayload <$> resultM
unfoldWith extract f (GoCursor (Cursor nextCursor)) = 
  let resultM :: m a = iterateWith (Just nextCursor)
  in  Just . extractPayload <$> resultM
unfoldWith _ StopCursor = pure Nothing
```

A `DirectMessages` is defined as:

```{.haskell .scrollx}
data DirectMessages = DirectMessages { messages :: [DirectMessage], cursorPosition :: Maybe T.Text } deriving Show
```

And now I just define a function that takes in a `DirectMessages` type and returns a pair of `([DirectMessage], CursorState)`:

```{.haskell .scrollx}
extractState :: DirectMessages -> ([DirectMessage], CursorState T.Text)
extractState (DirectMessages [] (Just c)) = ([], GoCursor (Cursor c)) -- No messages, but we have a cursor, then try to get more
extractState (DirectMessages [] Nothing)  = ([], StopCursor)          -- No messages and no cursor, then stop
extractState (DirectMessages msgs _)  = (msgs, StopCursor)            -- Messages so we can stop irrespective of cursor
```

Now I can call `unfoldrM` with:

```{.haskell .scrollx}
unfoldrM (unfoldWith extractState callTwitterApi) NewCursor
```

and we get pagination!

## A Simpler Example


If you got a little lost in the details of the above example don't worry. Here's a simpler example to give you some
intuition.

```{.haskell .scrollx}
-- Payload type
data Packet = Packet { value :: String, cursor :: Maybe (Cursor Int) }

-- Function that mimicks a server response
serviceCall :: forall m . Applicative m => Maybe (Cursor Int) -> m Packet
serviceCall Nothing = pure $ Packet "packet one" (Just $ Cursor 1)
serviceCall (Just (Cursor cur))
  | cur == 1  = pure $ Packet "packet two"   (Just $ Cursor 2)
  | cur == 2  = pure $ Packet "packet three" (Just $ Cursor 3)
  | cur == 3  = pure $ Packet "packet four"  (Just $ Cursor 4)
  | otherwise = pure $ Packet "packet five"  Nothing

-- Function that splits the payload into a result and the next CursorState
extractState :: Packet -> (String, CursorState Int)
extractState (Packet v (Just c)) = (v, GoCursor c)
extractState (Packet v Nothing)  = (v, StopCursor)
```

As before we can use it with:

```{.haskell .scrollx}
unfoldrM (unfoldWith extractState serviceCall) NewCursor
```

Using the above to log out the first three page responses:

```{.haskell .scrollx}
run :: IO ()
run = 
  let resultsIO :: IO [String] = unfoldrM (unfoldWith extractState serviceCall) NewCursor
      stringyfied :: IO String = (intercalate "," . take 3) <$> resultsIO
  in stringyfied >>= putStrLn
code
```

which prints out:

```{.haskell .scrollx}
packet two,packet three,packet four
```